#ifndef WITH_GL

// This makes use of SDL the internal sdl renderer to draw the software renderer.

#include <SDL.h>
// #include <SDL_image.h>

#include "main.h"
#include "../m68000.h"
#include "renderer.h"
#include "input.h"

unsigned long VideoBase;	/* Base address in ST Ram for screen(read on each VBL) */
unsigned char *VideoRaster; /* Pointer to Video raster, after VideoBase in PC address space. Use to copy data on HBL */

int len_main_palette;
unsigned short MainPalette[256];
unsigned short CtrlPalette[16];
int fe2_bgcol;

unsigned int MainRGBPalette[256];
unsigned int CtrlRGBPalette[16];

unsigned long logscreen, logscreen2, physcreen, physcreen2;

static SDL_Window *sdlWindow = NULL;
static SDL_Renderer *sdlRenderer = NULL;
static SDL_Texture *sdlTexture = NULL;
// static SDL_Surface *cursor = NULL;

BOOL bGrabMouse = FALSE; /* Grab the mouse cursor in the window */
BOOL bInFullScreen = FALSE;

/* new stuff */
enum RENDERERS use_renderer = R_OLD;
/* mouse shown this frame? */
int mouse_shown = 0;

/*-----------------------------------------------------------------------*/
/*
  Set window size
*/
// int screen_w = 320;
// int screen_h = 200;

int screen_w = 640;
int screen_h = 480;

static void change_vidmode()
{
	if (sdlWindow == NULL)
	{
		sdlWindow = SDL_CreateWindow(PROG_NAME,
									 SDL_WINDOWPOS_CENTERED, // Center the window
									 SDL_WINDOWPOS_CENTERED,
									 screen_w, screen_h,
									 SDL_WINDOW_SHOWN | (bInFullScreen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0));
		if (!sdlWindow)
		{
			fprintf(stderr, "Window creation failed: %s\n", SDL_GetError());
			SDL_Quit();
			exit(-1);
		}

		sdlRenderer = SDL_CreateRenderer(sdlWindow, -1, SDL_RENDERER_ACCELERATED);
		if (!sdlRenderer)
		{
			fprintf(stderr, "Renderer creation failed: %s\n", SDL_GetError());
			SDL_Quit();
			exit(-1);
		}

		// Create texture for the original game resolution (320x200)
		sdlTexture = SDL_CreateTexture(sdlRenderer,
									   SDL_PIXELFORMAT_RGB565, // TODO This could be SDL_PIXELFORMAT_ARGB8888 for better performance
									   SDL_TEXTUREACCESS_STREAMING,
									   320, 200);
		if (!sdlTexture)
		{
			fprintf(stderr, "Texture creation failed: %s\n", SDL_GetError());
			SDL_Quit();
			exit(-1);
		}
		SDL_SetTextureBlendMode(sdlTexture, SDL_BLENDMODE_NONE);

		SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
		SDL_RenderSetLogicalSize(sdlRenderer, screen_w, screen_h);
	}
	else
	{
		SDL_SetWindowSize(sdlWindow, screen_w, screen_h);
		SDL_SetWindowFullscreen(sdlWindow, bInFullScreen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0);
		SDL_RenderSetLogicalSize(sdlRenderer, screen_w, screen_h);
	}
}

void Screen_Init(void)
{
	SDL_ShowCursor(SDL_DISABLE);
	change_vidmode();

	/* Configure some SDL stuff: */
	SDL_SetWindowTitle(sdlWindow, PROG_NAME);
	SDL_EventState(SDL_MOUSEMOTION, SDL_ENABLE);
	SDL_EventState(SDL_MOUSEBUTTONDOWN, SDL_ENABLE);
	SDL_EventState(SDL_MOUSEBUTTONUP, SDL_ENABLE);
	SDL_ShowCursor(SDL_ENABLE);
}

void Screen_UnInit(void)
{
	if (sdlTexture)
	{
		SDL_DestroyTexture(sdlTexture);
		sdlTexture = NULL;
	}
	if (sdlRenderer)
	{
		SDL_DestroyRenderer(sdlRenderer);
		sdlRenderer = NULL;
	}
	if (sdlWindow)
	{
		SDL_DestroyWindow(sdlWindow);
		sdlWindow = NULL;
	}
}

void Screen_ToggleFullScreen()
{
	bInFullScreen = !bInFullScreen;
	change_vidmode();
}

static const unsigned char font_bmp[] = {
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x80, 0x80, 0x80, 0x80, 0x80, 0x0,
	0x80, 0x0, 0x0, 0x2, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x50,
	0xf8, 0x50, 0x50, 0xf8, 0x50, 0x0, 0x0, 0x6, 0x20, 0xf0, 0xa0, 0xa0, 0xa0, 0xa0, 0xf0, 0x20,
	0x0, 0x5, 0x0, 0xc8, 0xd8, 0x30, 0x60, 0xd8, 0x98, 0x0, 0x0, 0x6, 0xa0, 0x0, 0xe0, 0xa0,
	0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2,
	0xc0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0x0, 0x3, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x40,
	0x40, 0xc0, 0x0, 0x3, 0x0, 0x0, 0x20, 0xf8, 0x50, 0xf8, 0x20, 0x0, 0x0, 0x6, 0x0, 0x0,
	0x40, 0xe0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80,
	0x0, 0x2, 0x0, 0x0, 0x0, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x80, 0x0, 0x0, 0x2, 0x0, 0x8, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x0, 0x0, 0x6,
	0xe0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40,
	0xe0, 0x0, 0x0, 0x4, 0xe0, 0x20, 0x20, 0xe0, 0x80, 0x80, 0xe0, 0x0, 0x0, 0x4, 0xe0, 0x20,
	0x20, 0xe0, 0x20, 0x20, 0xe0, 0x0, 0x0, 0x4, 0x80, 0x80, 0xa0, 0xa0, 0xe0, 0x20, 0x20, 0x0,
	0x0, 0x4, 0xe0, 0x80, 0x80, 0xe0, 0x20, 0x20, 0xe0, 0x0, 0x0, 0x4, 0xe0, 0x80, 0x80, 0xe0,
	0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0xe0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0, 0x0, 0x4,
	0xe0, 0xa0, 0xa0, 0xe0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0xe0, 0xa0, 0xa0, 0xe0, 0x20, 0x20,
	0xe0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x80, 0x0, 0x80, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0,
	0x0, 0x80, 0x0, 0x0, 0x80, 0x80, 0x0, 0x2, 0xe0, 0x0, 0xe0, 0xa0, 0xa0, 0xa0, 0xa0, 0x0,
	0x0, 0x4, 0x0, 0x0, 0xe0, 0x0, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x4, 0xc0, 0x0, 0xe0, 0xa0,
	0xe0, 0x80, 0xe0, 0x0, 0x0, 0x4, 0xe0, 0x20, 0x20, 0xe0, 0x80, 0x0, 0x80, 0x0, 0x0, 0x4,
	0xfe, 0x82, 0xba, 0xa2, 0xba, 0x82, 0xfe, 0x0, 0x0, 0x8, 0xf0, 0x90, 0x90, 0x90, 0xf0, 0x90,
	0x90, 0x0, 0x0, 0x5, 0xf0, 0x90, 0x90, 0xf8, 0x88, 0x88, 0xf8, 0x0, 0x0, 0x6, 0xe0, 0x80,
	0x80, 0x80, 0x80, 0x80, 0xe0, 0x0, 0x0, 0x4, 0xf8, 0x48, 0x48, 0x48, 0x48, 0x48, 0xf8, 0x0,
	0x0, 0x6, 0xf0, 0x80, 0x80, 0xe0, 0x80, 0x80, 0xf0, 0x0, 0x0, 0x5, 0xf0, 0x80, 0x80, 0xe0,
	0x80, 0x80, 0x80, 0x0, 0x0, 0x4, 0xf0, 0x80, 0x80, 0x80, 0xb0, 0x90, 0xf0, 0x0, 0x0, 0x5,
	0x90, 0x90, 0x90, 0xf0, 0x90, 0x90, 0x90, 0x0, 0x0, 0x5, 0xe0, 0x40, 0x40, 0x40, 0x40, 0x40,
	0xe0, 0x0, 0x0, 0x4, 0xf0, 0x20, 0x20, 0x20, 0x20, 0x20, 0xe0, 0x0, 0x0, 0x4, 0x90, 0xb0,
	0xe0, 0xc0, 0xe0, 0xb0, 0x90, 0x0, 0x0, 0x5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe0, 0x0,
	0x0, 0x4, 0x88, 0xd8, 0xf8, 0xa8, 0x88, 0x88, 0x88, 0x0, 0x0, 0x6, 0x90, 0xd0, 0xf0, 0xb0,
	0x90, 0x90, 0x90, 0x0, 0x0, 0x5, 0xf0, 0x90, 0x90, 0x90, 0x90, 0x90, 0xf0, 0x0, 0x0, 0x5,
	0xf0, 0x90, 0x90, 0xf0, 0x80, 0x80, 0x80, 0x0, 0x0, 0x5, 0xf0, 0x90, 0x90, 0x90, 0x90, 0xb0,
	0xf0, 0x18, 0x0, 0x5, 0xf0, 0x90, 0x90, 0xf0, 0xe0, 0xb0, 0x90, 0x0, 0x0, 0x5, 0xf0, 0x80,
	0x80, 0xf0, 0x10, 0x10, 0xf0, 0x0, 0x0, 0x5, 0xe0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0,
	0x0, 0x3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xf0, 0x0, 0x0, 0x5, 0x90, 0x90, 0x90, 0xb0,
	0xe0, 0xc0, 0x80, 0x0, 0x0, 0x5, 0x88, 0x88, 0x88, 0xa8, 0xf8, 0xd8, 0x88, 0x0, 0x0, 0x6,
	0x88, 0xd8, 0x70, 0x20, 0x70, 0xd8, 0x88, 0x0, 0x0, 0x6, 0x90, 0x90, 0x90, 0xf0, 0x20, 0x20,
	0x20, 0x0, 0x0, 0x5, 0xf0, 0x10, 0x30, 0x60, 0xc0, 0x80, 0xf0, 0x0, 0x0, 0x5, 0xa0, 0x0,
	0xa0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0x0, 0x80, 0xc0, 0x60, 0x30, 0x18, 0x8, 0x0,
	0x0, 0x6, 0xe0, 0xa0, 0xa0, 0xe0, 0xa0, 0xa0, 0xe0, 0x80, 0x80, 0x4, 0xe0, 0xa0, 0xe0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf8, 0x0, 0x6,
	0xa0, 0x0, 0xe0, 0x20, 0xe0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0x0, 0x0, 0xe0, 0x20, 0xe0, 0xa0,
	0xe0, 0x0, 0x0, 0x4, 0x80, 0x80, 0xe0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0x0, 0x0,
	0xc0, 0x80, 0x80, 0x80, 0xc0, 0x0, 0x0, 0x3, 0x20, 0x20, 0xe0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0,
	0x0, 0x4, 0x0, 0x0, 0xe0, 0xa0, 0xe0, 0x80, 0xe0, 0x0, 0x0, 0x4, 0xc0, 0x80, 0x80, 0xc0,
	0x80, 0x80, 0x80, 0x0, 0x0, 0x3, 0x0, 0x0, 0xe0, 0xa0, 0xa0, 0xa0, 0xe0, 0x20, 0xe0, 0x4,
	0x80, 0x80, 0xe0, 0xa0, 0xa0, 0xa0, 0xa0, 0x0, 0x0, 0x4, 0x80, 0x0, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x0, 0x0, 0x2, 0x40, 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0, 0x0, 0x3, 0x80, 0x80,
	0xb0, 0xe0, 0xe0, 0xb0, 0x90, 0x0, 0x0, 0x5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x0,
	0x0, 0x2, 0x0, 0x0, 0xf8, 0xa8, 0xa8, 0xa8, 0xa8, 0x0, 0x0, 0x6, 0x0, 0x0, 0xe0, 0xa0,
	0xa0, 0xa0, 0xa0, 0x0, 0x0, 0x4, 0x0, 0x0, 0xe0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4,
	0x0, 0x0, 0xe0, 0xa0, 0xa0, 0xa0, 0xe0, 0x80, 0x80, 0x4, 0x0, 0x0, 0xe0, 0xa0, 0xa0, 0xa0,
	0xe0, 0x20, 0x30, 0x4, 0x0, 0x0, 0xc0, 0x80, 0x80, 0x80, 0x80, 0x0, 0x0, 0x3, 0x0, 0x0,
	0xc0, 0x80, 0xc0, 0x40, 0xc0, 0x0, 0x0, 0x3, 0x80, 0x80, 0xc0, 0x80, 0x80, 0x80, 0xc0, 0x0,
	0x0, 0x3, 0x0, 0x0, 0xa0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0x0, 0x0, 0xa0, 0xa0,
	0xe0, 0xc0, 0x80, 0x0, 0x0, 0x4, 0x0, 0x0, 0x88, 0xa8, 0xf8, 0xd8, 0x88, 0x0, 0x0, 0x6,
	0x0, 0x0, 0xa0, 0xe0, 0x40, 0xe0, 0xa0, 0x0, 0x0, 0x4, 0x0, 0x0, 0xa0, 0xa0, 0xa0, 0xa0,
	0xe0, 0x20, 0xe0, 0x4, 0x0, 0x0, 0xf0, 0x30, 0x60, 0xc0, 0xf0, 0x0, 0x0, 0x5, 0x81, 0x8d,
	0xe1, 0xa0, 0xa0, 0xa0, 0xa0, 0x0, 0x0, 0x9, 0x2, 0x1a, 0xc2, 0x80, 0xc0, 0x40, 0xc0, 0x0,
	0x0, 0x8, 0xfe, 0xfc, 0xf8, 0xfc, 0xfe, 0xdf, 0x8e, 0x4, 0x0, 0x7, 0x7f, 0x3f, 0x1f, 0x3f,
	0x7f, 0xfb, 0x71, 0x20, 0x0, 0x8, 0x4, 0x8e, 0xdf, 0xfe, 0xfc, 0xf8, 0xfc, 0xfe, 0x0, 0x8,
	0x20, 0x71, 0xfb, 0x7f, 0x3f, 0x1f, 0x3f, 0x7f, 0x0, 0x7, 0xff, 0x81, 0x81, 0x81, 0x81, 0x81,
	0x81, 0xff, 0x0, 0x9, 0x0, 0x0, 0xe0, 0x80, 0x80, 0x80, 0xe0, 0x40, 0xc0, 0x4, 0x60, 0x0,
	0xe0, 0xa0, 0xe0, 0x80, 0xe0, 0x0, 0x0, 0x4, 0xc0, 0x0, 0xa0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0,
	0x0, 0x4, 0x40, 0xa0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x4, 0x40, 0xa0, 0xe0, 0x20,
	0xe0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0x40, 0xa0, 0xe0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x4,
	0x40, 0xa0, 0xe0, 0xa0, 0xe0, 0x80, 0xe0, 0x0, 0x0, 0x4, 0xe0, 0x0, 0xa0, 0xa0, 0xa0, 0xa0,
	0xe0, 0x0, 0x0, 0x4, 0xc0, 0x0, 0xe0, 0x20, 0xe0, 0xa0, 0xe0, 0x0, 0x0, 0x4, 0xe0, 0xa0,
	0xa0, 0xa0, 0xe0, 0xa0, 0xa0, 0x0, 0x0, 0x4, 0xc0, 0xa0, 0xa0, 0xc0, 0xa0, 0xa0, 0xc0, 0x0,
	0x0, 0x4, 0xe0, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe0, 0x0, 0x0, 0x4, 0xc0, 0xa0, 0xa0, 0xa0,
	0xa0, 0xa0, 0xc0, 0x0, 0x0, 0x4, 0xe0, 0x80, 0x80, 0xe0, 0x80, 0x80, 0xe0, 0x0, 0x0, 0x4,
	0xe0, 0x80, 0x80, 0xe0, 0x80, 0x80, 0x80, 0x0, 0x0, 0x4};

static int DrawChar(int col, int xoffset, char *scrline, int chr)
{
	const char *font_pos;
	char *pix;
	int i;

	font_pos = font_bmp;
	font_pos += (chr & 0xff) * 10;
	scrline += xoffset;

	if (xoffset < 0)
	{
		font_pos += 9;
		return xoffset + *font_pos;
	}

	for (i = 0; i < 8; i++, font_pos++, scrline += SCREENBYTES_LINE)
	{
		pix = scrline;
		if (xoffset > 319)
			continue;
		if (*font_pos & 0x80)
			*pix = col;
		pix++;
		if (xoffset + 1 > 319)
			continue;
		if (*font_pos & 0x40)
			*pix = col;
		pix++;
		if (xoffset + 2 > 319)
			continue;
		if (*font_pos & 0x20)
			*pix = col;
		pix++;
		if (xoffset + 3 > 319)
			continue;
		if (*font_pos & 0x10)
			*pix = col;
		pix++;
		if (xoffset + 4 > 319)
			continue;
		if (*font_pos & 0x8)
			*pix = col;
		pix++;
		if (xoffset + 5 > 319)
			continue;
		if (*font_pos & 0x4)
			*pix = col;
		pix++;
		if (xoffset + 6 > 319)
			continue;
		if (*font_pos & 0x2)
			*pix = col;
		pix++;
		if (xoffset + 7 > 319)
			continue;
		if (*font_pos & 0x1)
			*pix = col;
	}
	/* width of character */
	font_pos++;
	i = *font_pos;
	return xoffset + i;
}

#define MAX_QUEUED_STRINGS 200
struct QueuedString
{
	int x, y, col;
	unsigned char str[64];
} queued_strings[MAX_QUEUED_STRINGS];
int queued_string_pos;

void Nu_QueueDrawStr()
{
	assert(queued_string_pos < MAX_QUEUED_STRINGS);
	// strncpy(queued_strings[queued_string_pos].str, GetReg(REG_A0) + STRam, 64);
	strncpy_s((char*)queued_strings[queued_string_pos].str, 64, GetReg(REG_A0) + STRam, 64);
	queued_strings[queued_string_pos].x = GetReg(REG_D1);
	queued_strings[queued_string_pos].y = GetReg(REG_D2);
	queued_strings[queued_string_pos++].col = GetReg(REG_D0);
}

int DrawStr(int xpos, int ypos, int col, unsigned char *str, bool shadowed)
{
	int x, y, chr;
	char *screen;

	x = xpos;
	y = ypos;

	if ((y > 192) || (y < 0))
		return x;
set_line:
	screen = LOGSCREEN2;
	screen += SCREENBYTES_LINE * y;

	while (*str)
	{
		chr = *(str++);

		if (chr < 0x1e)
		{
			if (chr == '\r')
			{
				y += 10;
				x = xpos;
				goto set_line;
			}
			else if (chr == 1)
				col = *(str++);
			continue;
		}
		else if (chr == 0x1e)
		{
			/* read new xpos */
			x = *(str++);
			x *= 2;
			continue;
		}
		else if (chr < 0x20)
		{
			/* Read new position */
			x = *(str++);
			x *= 2;
			y = *(str++);
			goto set_line;
		}

		if (shadowed)
		{
			DrawChar(0, x + 1, screen + SCREENBYTES_LINE, chr - 0x20);
		}
		x = DrawChar(col, x, screen, chr - 0x20);
	}

	return x;
}

void Screen_ToggleRenderer()
{
	use_renderer++;
	if (use_renderer >= R_MAX)
		use_renderer = 0;
}

// Convert 0x00RRGGBB to RGB565
static inline uint16_t convert_to_rgb565(uint32_t color)
{
	return ((color >> 8) & 0xF800) | ((color >> 5) & 0x07E0) | ((color >> 3) & 0x001F);
}

static uint16_t cached_main_pal[256];
static uint16_t cached_ctrl_pal[16];
static bool pal_dirty = TRUE;

static void cache_palettes() {
    if (!pal_dirty) return;
    
    for (int i = 0; i < 256; i++) {
        uint32_t col = MainRGBPalette[i];
        cached_main_pal[i] = ((col >> 8) & 0xF800) | ((col >> 5) & 0x07E0) | ((col >> 3) & 0x001F);
    }
    for (int i = 0; i < 16; i++) {
        uint32_t col = CtrlRGBPalette[i];
        cached_ctrl_pal[i] = ((col >> 8) & 0xF800) | ((col >> 5) & 0x07E0) | ((col >> 3) & 0x001F);
    }
    pal_dirty = FALSE;
}

static void draw_control_panel() {
    // Draw text (unchanged)
    int temp = logscreen2;
    logscreen2 = physcreen;
    for (int i = 0; i < queued_string_pos; i++) {
        DrawStr(queued_strings[i].x, queued_strings[i].y, queued_strings[i].col, queued_strings[i].str, FALSE);
    }
    logscreen2 = temp;

    // Lock texture
    void *pixels;
    int pitch;
    if (SDL_LockTexture(sdlTexture, NULL, &pixels, &pitch)) {
        return;
    }

    uint16_t *dst = (uint16_t *)pixels;
    uint8_t *src = VideoRaster;
    // uint8_t *src;

    // Precompute RGB565 palettes ONCE (reuse MainRGBPalette)
    static uint16_t main_pal_rgb565[256], ctrl_pal_rgb565[16];
    for (int i = 0; i < 256; i++) {
        uint32_t col = MainRGBPalette[i];
        main_pal_rgb565[i] = ((col >> 8) & 0xF800) | ((col >> 5) & 0x07E0) | ((col >> 3) & 0x001F);
    }
    for (int i = 0; i < 16; i++) {
        uint32_t col = CtrlRGBPalette[i];
        ctrl_pal_rgb565[i] = ((col >> 8) & 0xF800) | ((col >> 5) & 0x07E0) | ((col >> 3) & 0x001F);
    }
    main_pal_rgb565[255] = 0x0000; // Force transparency

    // Process all lines
    for (int y = 0; y < 200; y++) {
        uint16_t *row = dst + y * (pitch / 2);
        const uint16_t *pal = (y < 168) ? main_pal_rgb565 : ctrl_pal_rgb565;

        // Process 4 pixels at a time (reduces loop overhead)
        for (int x = 0; x < 320; x += 4) {
            row[x+0] = pal[src[y*320 + x+0]];
            row[x+1] = pal[src[y*320 + x+1]];
            row[x+2] = pal[src[y*320 + x+2]];
            row[x+3] = pal[src[y*320 + x+3]];
        }
    }

    SDL_UnlockTexture(sdlTexture);
    SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, NULL);
}

void BuildRGBPalette(unsigned int *rgb, unsigned short *st, int len) {
    for (int i = 0; i < len; i++) {
        unsigned short st_col = st[i];
        unsigned int r = ((st_col >> 8) & 0x0f) * 17;
        unsigned int g = ((st_col >> 4) & 0x0f) * 17;
        unsigned int b = (st_col & 0x0f) * 17;
        rgb[i] = 0xFF000000 | (r << 16) | (g << 8) | b;
    }
    pal_dirty = TRUE; // Mark palettes as needing update
}

void Nu_IsGLRenderer()
{
	SetReg(0, 0);
}

void Nu_DrawScreen()
{
	int y;

	BuildRGBPalette(MainRGBPalette, MainPalette, len_main_palette);
	BuildRGBPalette(CtrlRGBPalette, CtrlPalette, 16);

	y = logscreen2;
	logscreen2 = physcreen;
	logscreen2 = y;

	draw_control_panel();

	if (mouse_shown)
	{
		SDL_ShowCursor(SDL_ENABLE);
		mouse_shown = 0;
	}
	else
	{
		SDL_ShowCursor(SDL_DISABLE);
	}

	SDL_RenderPresent(sdlRenderer);
}

#endif